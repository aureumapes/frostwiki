{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to FrostWiki!","text":"<p>Thanks for visiting the site! I am the creator of it, FrostDracony (it's me AureumApes too :), and you can find here some tutorials of Slime Rancher modding. Click above on Slime Rancher to read the tutorials that are there.</p>"},{"location":"#links","title":"Links","text":"<ul> <li>Slime Rancher modding tutorials - Click here to access the Slime Rancher modding tutorials</li> </ul>"},{"location":"SlimeRancher/introduction/","title":"Introduction","text":"<p>First of all, the most important thing to know is that we're going to be using SRML to mod the game. I don't really learnt UMF and don't have intentions to do so, because in my opinion SRML is good enough. Here you will find some tutorials about modding Slime Rancher:</p>"},{"location":"SlimeRancher/introduction/#chapter-1-the-basics","title":"Chapter 1 - The basics","text":"<ol> <li>Getting started</li> <li>Making a crate vaccable</li> <li>Introduction to Enums Patching</li> </ol>"},{"location":"SlimeRancher/tutorials/cratevacc/","title":"Creating vaccable crates","text":"<p>Slime Rancher is a really complicated game to mod, so we will start with something that's simple: We all know that we can't collect crates, they stick on the vacuum gun and you can shoot them... but what if we can vacuum them? And that's what we are going to do!</p>"},{"location":"SlimeRancher/tutorials/cratevacc/#definitions","title":"Definitions","text":"<p>Here are the explanations of some words:</p> <p><code>Identifiable.Id</code>  The creator explained it on the github of SRML.</p> <p><code>Ammo</code> Ammo is the same as Inventory.</p> <p><code>Vaccumable/to vacuum</code> Collectable/to collect</p> <p><code>LookupDirector</code> The creator explained it on the github of SRML.</p> <p><code>PediaDirector</code> The creator explained it on the github of SRML.</p>"},{"location":"SlimeRancher/tutorials/cratevacc/#how-to-start","title":"How to start","text":"<p>Time to insert this code snippet in the Load or PostLoad function in our main class, you can choice where to put.</p> <p><pre><code>AmmoRegistry.RegisterAmmoPrefab(PlayerState.AmmoMode.DEFAULT, SRSingleton&lt;GameContext&gt;.Instance.LookupDirector.GetPrefab(Identifiable.Id.CRATE_PARTY_01));\nSprite icon = SRSingleton&lt;SceneContext&gt;.Instance.PediaDirector.entries.First((PediaDirector.IdEntry x) =&gt; x.id == PediaDirector.Id.ORNAMENTS).icon;\nLookupRegistry.RegisterVacEntry(Identifiable.Id.CRATE_PARTY_01, new Color32(138, 87, 40, 255), icon);\nSRSingleton&lt;GameContext&gt;.Instance.LookupDirector.GetPrefab(Identifiable.Id.CRATE_PARTY_01).GetComponent&lt;Vacuumable&gt;().size = Vacuumable.Size.NORMAL;\n</code></pre> Don\u2018t think I\u2018ll let you simply copy paste my code tho, it\u2018s time to explain what it does!</p>"},{"location":"SlimeRancher/tutorials/cratevacc/#first-line","title":"First Line","text":"<pre><code>AmmoRegistry.RegisterAmmoPrefab(PlayerState.AmmoMode.DEFAULT, SRSingleton&lt;GameContext&gt;.Instance.LookupDirector.GetPrefab(Identifiable.Id.CRATE_PARTY_01));\n</code></pre> <p>Now, lets start with the method <code>AmmoRegistry.RegisterAmmoPrefab</code>: We are making the crate vaccumable. This method accept 2 parameters: An <code>AmmoMode</code> Enum The target <code>GameObject</code> There only exist 2 AmmoMode:</p> <ul> <li><code>DEFAULT</code> (Normal)</li> <li><code>NIMBLE_VALLEY</code> (Once you pass the gate of Mochi, the item will disappear)</li> </ul> <p>For this tutorial we want the <code>DEFAULT</code> (Normal) Enum.</p> <p>Then, we need a <code>GameObject</code>, that means just an object of the game. We want to get the party crate object for this example.</p> <p><code>SRSingleton&lt;GameContext&gt;.Instance.LookupDirector</code> We are getting the <code>GameContext(SRSingleton&lt;GameContext&gt;.Instance)</code> to then get the <code>LookupDirector</code>. The <code>LookupDirector</code> contains a <code>GetPrefab</code> method, wich requires a <code>Identifiable.Id</code> and returns the desired <code>GameObject</code>. TL;DR (the second parameter) We are getting the <code>GameObject</code> of our Crate.</p>"},{"location":"SlimeRancher/tutorials/cratevacc/#second-line","title":"Second Line","text":"<pre><code>Sprite icon = SRSingleton&lt;SceneContext&gt;.Instance.PediaDirector.entries.First((PediaDirector.IdEntry x) =&gt; x.id == PediaDirector.Id.ORNAMENTS).icon;\n</code></pre> <p>All collectable objects of the game have their own picture, so why not our? And that's what we are doing!</p> <p><pre><code>Sprite icon = SRSingleton&lt;SceneContext&gt;.Instance.PediaDirector\n</code></pre> Like with the <code>LookupDirector</code>, we are getting the <code>PediaDirector</code> from the SceneContext.</p> <p><code>PediaDirector.entries</code> are all the icons/images of the game.</p> <p><code>entries.First((PediaDirector.IdEntry x) =&gt; x.id == PediaDirector.Id.ORNAMENTS).icon</code> means that we are targeting the Ornaments (These christmas-looking balls), getting an icon from some sort of object. You can change the <code>PediaDirector.Id</code> to the object that you want to have the image</p>"},{"location":"SlimeRancher/tutorials/cratevacc/#third-line","title":"Third Line","text":"<p><pre><code>LookupRegistry.RegisterVacEntry(Identifiable.Id.CRATE_PARTY_01, new Color32(138, 87, 40, 255), icon);\n</code></pre> Here we are assigning some background color and our icon to our crate.</p> <p><code>LookupRegistry.RegisterVacEntry</code> requires 3 parameters: * The <code>Identifiable.Id</code> of the object that we want to give the colour and icon * The Colour that we want to give * The Icon that we want to give</p> <p>We already have the Id and the Icon, but for the colour you will have to use a rgb sequence. You can go to this website; play around with the settings until you found your colour. Then just copy the number at the red (default 47), then green (default 50) and blue (default 159) slide and put them into the parameters of the <code>new Color32()</code>. So it would be <code>new Color32(47, 50, 159, 255)</code> (first red, then green and finally blue: This order has to be correct!). The last parameter, the 255, is needed for the transparency: You don't will need it.</p>"},{"location":"SlimeRancher/tutorials/cratevacc/#fourth-line","title":"Fourth Line","text":"<pre><code>SRSingleton&lt;GameContext&gt;.Instance.LookupDirector.GetPrefab(Identifiable.Id.CRATE_PARTY_01).GetComponent&lt;Vacuumable&gt;().size = Vacuumable.Size.NORMAL;\n</code></pre> <p>Here we are making the crate actually vaccumable. Remember, in the first line we only made it \"storagable\", so that it can enter the inventory, but if you would run your mod then the crate still will stick on the gun and not enter.</p> <p><code>SRSingleton&lt;GameContext&gt;.Instance.LookupDirector.GetPrefab(Identifiable.Id.CRATE_PARTY_01)</code>, this has been already seen on the first line, we are getting the GameObject of our crate.</p> <p><pre><code>.GetComponent&lt;Vacuumable&gt;().size = Vacuumable.Size.NORMAL;\n</code></pre> Now we are getting the \"Vacuumable Component\" (Think this like a folder), then changing the size property to <code>Vacuumable.Size.NORMAL</code>. We have 3 type of sizes: * NORMAL * LARGE * GIANT</p> <p>Normal is the normal size. This means it can be collected.</p> <p>Large means that it will stick on the vacuum gun (like a normal crate)</p> <p>Giant means that it can't be collected at all, like a gordo.</p>"},{"location":"SlimeRancher/tutorials/cratevacc/#fifthlast-line","title":"Fifth/Last Line","text":"<p><pre><code>TranslationPatcher.AddActorTranslation(\"l.crate_party_01\", \"Party Crate\");\n</code></pre> You can leave it, but this will add the little \"Party Crate\" name in your inventory when you are storing a party crate. We are doing this because crates aren't vacuumable, so there dosen't exist any name that should show up when you have one crate in your inventory. So we have to add one ourself!</p>"},{"location":"SlimeRancher/tutorials/cratevacc/#conclusion","title":"Conclusion","text":"<p>This is a long tutorial, but only because I tried to explain everything in details. This is really confusing at start, but you will get the point. Anyways, the next tutorial part is to add custom slimes (warning, it's a really long part), so enjoy your new crate!</p> <p>P.S.</p> <p>But FrostDracony, where can I find a party crate? I don't want to search the entire map for one! Ok, keep calm: Just spawn one! On Windwos, you can press <code>Ctrl + Tab</code> to access the command bar. Type in spawn <code>CRATE_PARTY_01</code> and a party crate should spawn where you were looking at! (If it doesn't spawn, then it probably spawned below the map.. Just find a flat place like the ranch and retry the command)</p>"},{"location":"SlimeRancher/tutorials/enums/","title":"Enum Patching","text":""},{"location":"SlimeRancher/tutorials/enums/#little-explanation","title":"Little explanation","text":"<p>Now, what are ids? Id stands for identifier, the most used enum type would be <code>Identifiable.Id</code>. Why do we need that? Now, very much simplifeid, as the name already implies it itself, think of ids as a way to distinguish things from each other, for example, an hen would have a different <code>Identifiable.Id</code> than a Pink Slime, it's like the object's \"family names\" basically.</p> <p>Now, of course, the ids for our future custom objects don't exist yet, hence why this tutorial in first place!</p>"},{"location":"SlimeRancher/tutorials/enums/#manual","title":"Manual","text":"<p>Now, there are two ways at registering our enums, the first one is what I call \"manual\" and the second \"automatic\", we're starting with what I refer to \"manual\". To add new values to enums (for example, our popular <code>Identifiable.Id</code> one, we can use a static class called <code>EnumPatcher</code> inside the main <code>SRML</code> namespace. However, be aware, there are some enums that can only be registered using some Registry classes instead of the <code>EnumPatcher</code>. To add a new value to an enum with <code>EnumPatcher</code>, we use <code>EnumPatcher.AddEnumValue(Type enumType, object value, string name)</code>.</p>"},{"location":"SlimeRancher/tutorials/enums/#automatic","title":"Automatic","text":"<p>In this method,SRML provides us with an easy method for this, it's an attribute called EnumHolder in the <code>SRML.Utils.Enum</code> namespace. Simply attach this attribute to a static class and when your mod is loaded, SRML will then proceed to register and assign all readonly static fields with the first available free value in that enum. Basically:</p> <pre><code>[EnumHolder]\npublic static class ModdedIds\n{\n    public static readonly Identifiable.Id CUSTOM_IDENTIFIABLE; // Creating a new Identifiable.id, the first value in Identifiable.Id has the name CUSTOM_IDENTIFIABLE\n    public static readonly Gadget.Id TEST_GADGET; // Even tho it's another type of id, in this case for gadgets, it works the same way as the example above!\n}\n</code></pre>"},{"location":"SlimeRancher/tutorials/enums/#conclusion","title":"Conclusion","text":"<p>When should we use the one method and the other, what are the differences of between? Basically, this takes some setup, but it's going to pay off in the long ride. It's way easier and comfortable than the manual method. However, since the manual method doesn't requires classes and etc, it's way more flexible (you can create codes in between the lines incase you're counting to use them just once), however requires more work. For the beginning, just consider the automatic!</p>"},{"location":"SlimeRancher/tutorials/getting_started/","title":"Getting Started","text":""},{"location":"SlimeRancher/tutorials/getting_started/#requisites","title":"Requisites","text":"<ul> <li>Visual Studio</li> <li>Basic knowledge of C#</li> <li>Having SRML already installed</li> </ul> <p>In the case you havent downloaded Visual Studio, you should follow this wonderful tutorial (choose the community option, that\u2018s the free one)</p> <p>For learning basic knowledge of C#, you can look at this excellent playlist from Brackeys.</p> <p>If you won\u2018t have the requisites, don\u2018t expect me explaining it to you.</p> <p>To get SRML, go on it\u2018s NexusMods\u2018 page and follow the instructions there. You can also follow some tutorials on youtube about it.</p>"},{"location":"SlimeRancher/tutorials/getting_started/#honorable-mentions","title":"Honorable Mentions","text":"<ul> <li>mikel veesus heir: many images that I don\u2018t write below \u201ecredited by X\u201c are from mikel\u2018s own wiki. Also of course his SRML, without it, we would need other ways to mod.</li> <li>MrPurple/CabbageCrow: for the assembly publicizer (I think I should mention the creator of the program)</li> </ul>"},{"location":"SlimeRancher/tutorials/getting_started/#introduction","title":"Introduction","text":"<p>Now, let\u2018s gather up some energy, because this first tutorial will be a long and a bit complicated one. We\u2018re going to install a lot of stuff, so no codding at this point. Also, because I only have Windows, this is a tutorial for Windows users (yet). Because First step: Let\u2018s start a project!</p>"},{"location":"SlimeRancher/tutorials/getting_started/#setting-up-the-project","title":"Setting up the project","text":"<p>I assume you\u2018ve already installed Visual Studio (read the requisites) then set up a project in there. Now, you can use any other IDE if you have one, like JetBrain\u2018s Rider IDE, but VisualStudio is the only one I know that\u2018s free and can do what we need for modding. (So yea, this whole tutorial is basically about visual studio).</p>"},{"location":"SlimeRancher/tutorials/getting_started/#how-to-set-up-a-new-project-in-visual-studio","title":"How to set up a new project in Visual Studio","text":"<p>After finally installing VisualStudio, together with C#, we now need to start a project! Select a .NET Framework Class Library for C# Project.</p> <p></p> <p>(Credits to veesus mikel heir for the image__)</p> <p>After clicking to <code>Next</code>, we\u2018ll land to the <code>Configure your new Project</code>, page.</p> <p></p> <p>(Credits to veesus mikel heir for the image__)</p> <p>Here, we can set our:</p> <ul> <li>project\u2018s name (pretty self-explanatory)</li> <li>the location (only touch it if you want to have the project on a special folder, else leave this setting)</li> <li>the solution\u2018s name (the [NAME_OF_MOD].dll file you download and use for playing the mods, here it\u2018s the name of that .dll file)</li> </ul> <p>You can change the project\u2018s name and the solution\u2018s name, but I suggest you to only use this first mod to follow the content of this tutorial series. I\u2018m saying this so that you can concentrate about knowing the structure of a mod, before starting your private one, but feel free to do what you want, it\u2018s only a suggestion.</p> <p>Anyways for this tutorial we\u2018re using the name \u201eMyFirstMod\u201c for the Project and Solution.</p>"},{"location":"SlimeRancher/tutorials/getting_started/#adding-the-needed-references","title":"Adding the needed references","text":"<p>Mentions: Because I can\u2018t take screenshots on my laptop, I\u2018m going to instead use the pictures of veesus (this is all WIP so I dont think I\u2018m actually going to show this to anyone, but if anyone sees this, atleast you\u2018re warned about screenshots not matching what I wrote until now).</p> <p>After that, we need to setup the references we need in order to allow us to even start modding (and we make sure to use the publicized assemblies of SRML and Assembly-C).</p> <p>In the solution explorer on the right side of the screen there\u2018s an option called\u00a0References.</p> <p></p> <p>After right clicking on this option, click\u00a0the Add Reference... button</p> <p></p> <p>Once getting on this menu, select the\u00a0Browse...\u00a0option in the bottom right corner</p> <p></p> <p>(Credits to veesus mikel heir for the images__)</p> <p>The .dll references needed are located in\u00a0the <code>&lt;slime rancher game folder&gt;/SlimeRancher_Data/Managed</code>\u00a0folders as well as\u00a0in <code>&lt;slime rancher game folder&gt;/SRML/Libs</code>, those include the: Assembly-CSharp_old.dll (NOT Assembly-CSharp-firstpass.dll or Assembly-CSharp.dll), SRML.dll, 0Harmony.dll\u00a0and any UnityEngine .dll files you'll need for your mod (We'll start with\u00a0UnityEngine.CoreModule.dll\u00a0for now).</p> <p></p> <p></p> <p>(Credits to veesus mikel heir for the images__)</p> <p>See those .dll files? Those are the ones you want to use <code>MrPurple\u2018s AssemblyPublicizer</code> on. Use the AssemblyPublicizer and select the new .dll files, once done that click the <code>Add</code> button near the under right corner and you have your references!</p>"},{"location":"SlimeRancher/tutorials/getting_started/#the-maincs-modinfojson-files-and-build-events","title":"The <code>Main.cs</code>, <code>modinfo.json</code> files and Build events","text":"<p>Time to set up the <code>Main.cs</code>, <code>modinfo.json</code> files and to add the build events. The <code>Main.cs</code> is going to be the mod\u2018s entry point, the <code>modinfo.json</code> is going to be the file that allows SRML to recognize your mod as a mod and we can use build events to speed up our working. More in details later on.</p>"},{"location":"SlimeRancher/tutorials/getting_started/#building-the-dll","title":"Building the .dll","text":"<p>Lets start by build events. Everytime we\u2018re done codding our mod, we usually need to manually take the <code>MyFirstMod.dll</code> generated in <code>[YourRepository]/bin/Debug</code> (the name depends of what you\u2018ve chosen at the beginning, you\u2018ll find the SolutionsName.dll file there, in our case we\u2018ve written <code>MyFirstMod</code>).</p> <p>First, we need to know 2 different paths: the path of your <code>MyFirstMod.dll</code> and the path of your Mods folder.</p> <p>To get the first path, first you should build your project (do that every time you want to update your builded .dll file).</p> <p>To do that, click on the\u00a0Build\u00a0tab at the top of the screen, then select\u00a0Build Solution.</p> <p></p> <p>If done correctly, and your code generates no error at building time, you should see\u00a0Build Succeeded\u00a0at the bottom of your screen.</p> <p></p> <p>Finally, we can access the created <code>MyFirstMod.dll</code> file, by right clicking on the project, then selecting\u00a0Open Folder in File Explorer.</p> <p></p> <p>Now naviguate to <code>/bin/Debug</code>. And there you should find your <code>MyFirstMod.dll</code> file. Now, you can just drag it to your Mods folder.</p>"},{"location":"SlimeRancher/tutorials/getting_started/#maincs","title":"Main.cs","text":"<p>Our first mod is almost ready to run! But there are still some steps to do. First we need to create an entry point for the mod to start execution at. SRML provides an abstract class to help us achieve this, it\u2018s called\u00a0ModEntryPoint\u00a0in the SRML namespace. Thanks to it, SRML will auto-detect a class extending ModEntryPoint and run the code found in certain methods inside it, those methods are\u00a0PreLoad, Load, and PostLoad.</p> <p>Important note: You usually should have a class called <code>Class1.cs</code>, we\u2018re going to rename it (F2) to our <code>Main.cs</code>.</p>"},{"location":"SlimeRancher/tutorials/getting_started/#preload","title":"PreLoad","text":"<p>Everything inside Preload will be executed before you enter your game (more about GameContext and SceneContext on a later chapter).</p> <p>What you need to know for now is that the <code>HarmonyInstance.PatchAll();</code> is needed, if that isn\u2018t present in PreLoad (and it can only be present in Preload), then your whole mod wont probably work. More about HarmonyPatching in later chapters.</p> <p>Also, if we want to register (aka make so that the game can recognise it) an object to the game, or add manually new enum values (the id of your object), then it\u2018s here that happens. If you don\u2018t get it, no worries, everything\u2018s going to be explained with some examples later on.</p>"},{"location":"SlimeRancher/tutorials/getting_started/#load","title":"Load","text":"<p>Everything inside Load will be executed when the game starts. Here it\u2018s where most of registering stuff happen. For example, we write here when we\u2018re registering a slime, food, or etc.</p>"},{"location":"SlimeRancher/tutorials/getting_started/#postload","title":"PostLoad","text":"<p>Everything inside here will be executed after the game has already loaded. It\u2018s perfect to modify things that already exist in game, like a texture, color, and etc. But it\u2018s not a place to register new things, because at this point, the game has already loaded, and you can\u2018t add new things to the game if it\u2018s already loaded.</p>"},{"location":"SlimeRancher/tutorials/getting_started/#the-modentrypoint","title":"The ModEntryPoint","text":"<p>So, after having explored the 3 functions, now it\u2018s time to see how to use the ModEntryPoint abstract class.</p> <pre><code>using SRML;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\n// Feel free to change the namespace to another name\nnamespace MyFirstMod\n{\n    public class Main : ModEntryPoint\n    {\n        // Called before GameContext.Awake\n        // You want to register new things and enum values here, as well as do all your harmony patching\n        public override void PreLoad()\n        {\n            HarmonyInstance.PatchAll();\n        }\n\n\n        // Called before GameContext.Start\n        // Used for registering things that require a loaded gamecontext\n        public override void Load()\n        {\n\n        }\n\n        // Called after all mods Load's have been called\n        // Used for editing existing assets in the game, not a registry step\n        public override void PostLoad()\n        {\n\n        }\n\n    }\n}\n</code></pre>"},{"location":"SlimeRancher/tutorials/getting_started/#modinfojson","title":"modinfo.json","text":"<p>Now, the last thing to set up is the modinfo.json file. It\u2018s needed to SRML to recognise the mod at all.</p> <p>First, start by creating an text file, and rename it to <code>modinfo.json</code>.</p> <p></p> <p></p> <p>Now, write this in the file (it\u2018s a template, so feel free to copy it):</p> <pre><code>{\n  \"id\": \"myfirstmod\",\n  \"name\": \"My First Mod\", \n  \"author\": \"frostdracony\", \n  \"description\": \"This is the first mod I have ever made!\", \n  \"version\":  \"1.0\" \n}\n</code></pre> <p>Now, after saving it, select the file in your solution explorer. We can find lots of information about the file at the bottom of the solution explorer, included an option that reads,\u00a0Build Action. By clicking on it and selecting\u00a0Embedded Resource. This will make the C# compiler include your modinfo.json in your mods final .dll, thus allowing it to be recognized by SRML.</p> <p></p>"},{"location":"SlimeRancher/tutorials/getting_started/#building-and-testing","title":"Building and testing","text":"<p>Now that we have our Main.cs and modinfo.json files, it's time to build and test your mod! To build a project in visual studio, click on the\u00a0Build\u00a0tab at the top of the screen and select\u00a0Build Solution.</p> <p></p> <p>If done correctly, and your code generates no error at building time, you should see\u00a0Build Succeeded\u00a0at the bottom of your screen.</p> <p></p> <p>Finally, we can access the created <code>MyFirstMod.dll</code> file, by right clicking on the project, then selecting\u00a0Open Folder in File Explorer.</p> <p></p> <p>Now navigate to <code>/bin/Debug</code>. And there you should find your <code>MyFirstMod.dll</code> file. Now, you can just copy-paste it to your Mods folder.</p> <p>Now just start slime rancher and you should see, after clicking the Mods tab, your mod information. If it\u2018s there, then your first mod is ready!</p> <p></p> <p>Now, for now, your mod isn\u2018t doing anything. Now, after all that setup, we can finally start the fun part about modding in the next tutorials. There are some optional things we can do, but you\u2018re not forced to. Else:</p> <p>I wish you good luck with your modding adventure!</p>"},{"location":"SlimeRancher/tutorials/getting_started/#optional","title":"Optional","text":""},{"location":"SlimeRancher/tutorials/getting_started/#build-events-recommended","title":"Build events (RECOMMENDED)","text":"<p>Now, to be honnest, after a while, having to drag your mod DLL everytime to the Mods folder can become tiring. For this, we can automize the proccess of it.</p> <p>Now, instead of dragging the build (aka <code>MyFirstMod.dll</code>) to the Mods folder, copy it\u2018s path (right click on your <code>MyFirstMod.dll</code> and select Copy as path)</p> <p></p> <p>(Example image, credits to the How-To Geek website).</p> <p>After doing this, you can go to the Build Event tab on your Settings</p> <p></p> <p>(Image from Mitesh Sureja\u2018s Blog)</p> <p>Now in theh Post-build event command line, add this: <code>xcopy \"(PathToCopyFrom)\" \"(TargetPath)\"</code></p> <p>Now, replace the <code>\"(PathToCopyFrom)\"</code> with the copy I asked you to copy before, the path to <code>MyFirstMod.dll</code>. You should now add the <code>MyFirstMod.dll</code> at the end of your copied path, so the first half looks like <code>xcopy \"YourPath\\MyFirstMod.dll\" \"(TargetPath)\"\"</code>.</p> <p>Now lets focus on the <code>\"(TargetPath)\"</code>, you just need to locate your Mods folder (the one where you usually add your mods to play modded SlimeRancher), and same as for the <code>MyFirstMod.dll</code>, right click and press Copy as path.</p> <p>Now finally replace the with your copied path, and the first half is done!</p> <p>The command we\u2018ve written in the Post-build event command line will make it easier for us to copy that .dll file into the Mods folder.</p> <p>Now, to make it work, just build the mod and the game should start all by itself!</p>"},{"location":"SlimeRancher/tutorials/getting_started/#mrpurples-assemblypublicizer","title":"MrPurple\u2018s AssemblyPublicizer","text":"<p>Now, I would like to mention that this is a upgraded version of CabbageCrow\u2018s AssemblyPublicizer, but considering it has some issues that will become visible later on, we\u2018re using this upgraded one. Shout to CabbageCrow!</p> <p>We will have to use <code>MrPurple\u2018s AssemblyPublicizer</code> to allow us to access every property we\u2018re going to need in our modding journey. It allows us to convert a .dll file with lots of <code>private</code> elements (aka properties, variables, functions, etc\u2026) to a copy of it, containing only <code>public</code> elements. In other words: \u201cThings we can\u2018t access become accessible for our code\u201c.</p> <p>It\u2018s like a big house where every door is closed, you have no way to open them by yourself. Now the AssemblyPublicizer comes in game and opens magically for you all the doors! ~~(It actually recreates the house and keeps the doors open, creating a copy of the closed house, but let\u2018s pretend it just opens them by magic)~~</p> <p>You can download it here.</p> <p>Now, how to use it? It\u2018s written on the github page (so I won\u2018t explain it here) Now, where we use it? Wait for the \u201cAdding the needed references\u201c section</p>"},{"location":"SlimeRancher/tutorials/getting_started/#setting-allow-unsafe-code","title":"Setting \u201eAllow unsafe code\u201c","text":"<p>Now, talking for experience (painful hours wasted for this 1 single thing), we\u2018re going to need to set a compiler option, else every time we\u2018re going to build the project it\u2018s going to result into an error. For this we need to set the \u201eallow unsafe code\u201c option to true. There are 2 ways to achieve this, one via the IDE, one via editing the .csproj of the project.</p> <p>1. For the first way, proceed to open the project's Properties page in your Visual Studio development environment (aka IDE). Click the Build property page, then select the Allow Unsafe Code check box.</p> <p>2. For the second way, open your .csproj file and add this snippet below:</p> <pre><code>  &lt;PropertyGroup&gt;\n    &lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;\n  &lt;/PropertyGroup&gt;\n</code></pre> <p></p> <p>(Credit to this StackOverflow post, a bit outdated, but it still works with modern Visual Studio versions)</p>"},{"location":"SlimeRancher/tutorials/getting_started/#adding-the-new-references","title":"Adding the new references","text":"<p>Just remove the old references and add the publicized ones. After all what we\u2018ve done yet, you should be able to access codes you first weren\u2018t able to touch!</p>"},{"location":"SlimeRancher/tutorials/images/","title":"Loading Images","text":""},{"location":"SlimeRancher/tutorials/images/#adding-images-to-your-project","title":"Adding Images to your project","text":"<p>Simply add the image files to your project files and configure them as EmbededResource, just as the modinfo.json. Make sure, that your file is a png, you may have to change the upcoming function if you use a jpeg or bitmap.</p>"},{"location":"SlimeRancher/tutorials/images/#loading-said-images","title":"Loading said Images","text":"<p>You can easily write a Utility Class, with a method to load Sprites from your Assemblies Resources: Utility Class<pre><code>namespace YourMod\n{\n    public static class Utility\n    {\n        public static Texture2D LoadTextureFromAssembly(string filename)\n        {\n            var executingAssembly = Assembly.GetExecutingAssembly();\n            var manifestResourceStream = executingAssembly.GetManifestResourceStream(executingAssembly.GetName().Name + \".\" + filename + \".png\");\n            var numArray = new byte[manifestResourceStream.Length];\n            manifestResourceStream.Read(numArray, 0, numArray.Length);\n            var tex = new Texture2D(1, 1);\n            tex.LoadImage(numArray);\n            tex.filterMode = FilterMode.Bilinear;\n            return tex;\n        }\n\n        public static Sprite ConvertToSprite(this Texture2D texture)\n        {\n            return Sprite.Create(texture, new Rect(0.0f, 0.0f, texture.width, texture.height), new Vector2(0.5f, 0.5f), 1f);\n        }\n    }\n}\n</code></pre></p>"},{"location":"SlimeRancher/tutorials/Creating%20Content/foodgroup/","title":"Adding a Food Group","text":"<p>If you want to add an Food Group to the Game you'll need multiple patches don.</p> <p>First things first, define the Food Class: <pre><code>namespace YourMod\n{\n    public class FoodClass\n    {\n        internal static Identifiable.Id[] YOUR_FOOD_CLASS =\n        {\n            Identifiable.Id.WILD_HONEY_CRAFT,\n            Identifiable.Id.ROYAL_JELLY_CRAFT,\n            Identifiable.Id.HONEY_PLORT\n        };\n    }\n}\n</code></pre> you can, of course change the items contained in the class, feel free to play around with it</p> <p>Add following entry to your ModdedIds: ModdedIds<pre><code>public static readonly SlimeEat.FoodGroup YOUR_FOODGROUP;\n</code></pre></p> <p>Now we'll come to the harder part: patch the existing SlimeEat and SlimeDiet class:</p> <p>FoodPatch Class<pre><code>using System.Linq;\n\nnamespace YourMod\n{\n    internal class FoodPatch\n    {\n        [HarmonyLib.HarmonyPatch(typeof(SlimeEat))]\n        [HarmonyLib.HarmonyPatch(\"GetFoodGroupIds\")]\n        internal static class FoodGroupPatch\n        {\n            public static void Postfix(ref Identifiable.Id[] __result, SlimeEat.FoodGroup group)\n            {\n                if (!SlimeEat.foodGroupIds.ContainsKey(ModdedIds.YOUR_FOODGROUP))\n                    SlimeEat.foodGroupIds.Add(ModdedIds.YOUR_FOODGROUP, FoodClass.YOUR_FOOD_CLASS);\n                if (__result == null)\n                    return;\n                var list = __result.ToList();\n                if (group == ModdedIds.YOUR_FOODGROUP)\n                    foreach (var id in FoodClass.YOUR_FOOD_CLASS)\n                        list.Add(id);\n            }\n        }\n    }\n\n    [HarmonyLib.HarmonyPatch(typeof(SlimeDiet))]\n    [HarmonyLib.HarmonyPatch(\"GetFoodCategoryMsg\")]\n    internal static class FoodGroupPatchMsg\n    {\n        public static bool Prefix(ref string __result, Identifiable.Id id)\n        {\n            if (SlimeEat.GetFoodGroupIds(ModdedIds.YOUR_FOODGROUP).Contains(id))\n                __result = \"m.foodgroup.\" + ModdedIds.YOUR_FOODGROUP.ToString().ToLower();\n            return false;\n        }\n    }\n}\n</code></pre> And your done. Use the FoodGroup Id, as you want</p>"},{"location":"SlimeRancher/tutorials/Creating%20Content/plorts/","title":"Adding Plorts","text":""},{"location":"SlimeRancher/tutorials/Creating%20Content/plorts/#creating-an-id-for-your-plort","title":"Creating an ID for your Plort","text":"<p>Just like when creating a Slime, you have to add this line to your EnumHolder: EnumHolder<pre><code>public static readonly Identifiable.Id YOUR_PLORT;\n</code></pre></p>"},{"location":"SlimeRancher/tutorials/Creating%20Content/plorts/#adding-the-plort-and-its-behaviours","title":"Adding the Plort and its behaviours","text":"<p>Create a new File containing this code: CreatePlort<pre><code>namespace YourMod\n{\n    public class CreatePlort\n    {\n        public static void CreateYourPlort()\n        {\n            var b = PrefabUtils.CopyPrefab(\n                SRSingleton&lt;GameContext&gt;.Instance.LookupDirector.GetPrefab(Identifiable.Id.PINK_PLORT));\n            b.GetComponent&lt;Identifiable&gt;().id = ModdedIds.YOUR_PLORT;\n            b.name = \"Your Plort\";\n            LookupRegistry.RegisterIdentifiablePrefab(b);\n            b.GetComponent&lt;MeshRenderer&gt;().material = Object.Instantiate(b.GetComponent&lt;MeshRenderer&gt;().material);\n            b.GetComponent&lt;MeshRenderer&gt;().material.SetColor(\"_TopColor\", new Color(0,0,0,0));\n            b.GetComponent&lt;MeshRenderer&gt;().material.SetColor(\"_MiddleColor\", new Color(0,0,0,0));\n            b.GetComponent&lt;MeshRenderer&gt;().material.SetColor(\"_BottomColor\", new Color(0,0,0,0));\n            SlimeEat.FoodGroup.PLORTS.UnregisterId(ModdedIds.YOUR_PLORT);\n            b.GetComponent&lt;MeshRenderer&gt;().material.SetColor(\"_CrackColor\", new Color(0,0,0,0));\n            AmmoRegistry.RegisterAmmoPrefab(PlayerState.AmmoMode.DEFAULT,\n                SRSingleton&lt;GameContext&gt;.Instance.LookupDirector.GetPrefab(ModdedIds.YOUR_PLORT));\n            SRSingleton&lt;GameContext&gt;.Instance.LookupDirector.GetPrefab(ModdedIds.YOUR_PLORT).GetComponent&lt;Vacuumable&gt;()\n                .size = Vacuumable.Size.NORMAL;\n            TranslationPatcher.AddActorTranslation(\"l.your_plort\", \"Your Plort\");\n            var icon = Texture.LoadTextureFromAssembly(\"yourPlortIcon\").AsSprite();\n            LookupRegistry.RegisterVacEntry(ModdedIds.YOUR_PLORT, Main.color1, icon);\n            PlortRegistry.RegisterPlort(ModdedIds.YOUR_PLORT, 100f, 10f);\n            DroneRegistry.RegisterBasicTarget(ModdedIds.YOUR_PLORT);\n        }\n    }\n}\n</code></pre> To make your Slimes actually producing their plorts, you have to add the Plort to the </p>"},{"location":"SlimeRancher/tutorials/Creating%20Content/slimes/","title":"Adding Slimes","text":""},{"location":"SlimeRancher/tutorials/Creating%20Content/slimes/#adding-an-id-for-your-slime","title":"Adding an ID for your Slime","text":"<p>Its important, that your Slime has an ID, to refer to it via code and when in game. You can add one by creating an Enum that you add to your Enum Holder: ModdedIds EnumHolder<pre><code>namespace YourMod\n{\n    [EnumHolder]\n    public class ModdedIds\n    {\n        public static readonly Identifiable.Id YOUR_SLIME;\n    }\n}\n</code></pre></p>"},{"location":"SlimeRancher/tutorials/Creating%20Content/slimes/#making-the-slime","title":"Making the Slime","text":"<p>Now create a new class and a new static void inside that class: CreateSlime Class<pre><code>using System;\nusing SRML.SR;\nusing SRML.Utils;\nusing UnityEngine;\nusing Object = UnityEngine.Object;\n\nnamespace DreamSlimes.Slimes\n{\n    public class CreateSlime\n    {\n        public static void CreateYourSlime()\n        {\n            // Copy the Prefab for the Pink Slime\n            var slimeByIdentifiableId =\n                SRSingleton&lt;GameContext&gt;.Instance.SlimeDefinitions.GetSlimeByIdentifiableId(Identifiable.Id.PINK_SLIME);\n            var slimeDefinition = (SlimeDefinition)PrefabUtils.DeepCopyObject(slimeByIdentifiableId);\n            slimeDefinition.AppearancesDefault = new SlimeAppearance[1];\n\n            // Adding an eat map to the Slime, which allows it to eat something\n            slimeDefinition.Diet.Produces = new[] { ModdedIds.YOUR_PLORT };\n            slimeDefinition.Diet.MajorFoodGroups = new[] { SlimeEat.FoodGroup.PLORTS };\n            slimeDefinition.Diet.Favorites = new[] { Identifiable.Id.SABER_PLORT };\n            slimeDefinition.Diet.EatMap?.Clear();\n\n            // Setting basic preferences for the Slime\n            slimeDefinition.CanLargofy = false; // Slime can't become a largo\n            slimeDefinition.FavoriteToys = Array.Empty&lt;Identifiable.Id&gt;(); // Clear the Favourite Toy lsit\n            slimeDefinition.Name = \"Your Slime\"; // Change the name of the Slime\n            slimeDefinition.IdentifiableId = ModdedIds.YOUR_SLIME; // Setting the ID of the SLime to be your previously made Enum\n\n            // Creating and Modifying the Slimes GameObject\n            var go =\n                PrefabUtils.CopyPrefab(\n                    SRSingleton&lt;GameContext&gt;.Instance.LookupDirector.GetPrefab(Identifiable.Id.PINK_SLIME)); // Copy the prefab GO\n            go.name = \"Dream_Slime\"; // Setting the name of the GO in the Editor and in the Game\n            // Setting the previously created SlimeDefinition to be the one for some of the GO-Components\n            go.GetComponent&lt;PlayWithToys&gt;().slimeDefinition = slimeDefinition;\n            go.GetComponent&lt;SlimeAppearanceApplicator&gt;().SlimeDefinition = slimeDefinition;\n            go.GetComponent&lt;SlimeEat&gt;().slimeDefinition = slimeDefinition;\n            go.GetComponent&lt;Identifiable&gt;().id = Id.DREAM_SLIME;\n            go.GetComponent&lt;Vacuumable&gt;().size = Vacuumable.Size.LARGE;\n            go.transform.localScale = new Vector3(0.75f, 0.75f, 0.75f); // Resizing the Slime\n            Object.Destroy(go.GetComponent&lt;PinkSlimeFoodTypeTracker&gt;()); // Destroy the Tracker of the Pink SLime\n\n            // Modifying the Slimes Appearance (Color etc.)\n            var slimeAppearance =\n                (SlimeAppearance)PrefabUtils.DeepCopyObject(slimeByIdentifiableId.AppearancesDefault[0]);\n            slimeDefinition.AppearancesDefault[0] = slimeAppearance;\n            var structures = slimeAppearance.Structures;\n            var structures2 = structures;\n            foreach (var structure in structures2)\n            {\n                var defaultMaterials = structure.DefaultMaterials;\n                if (defaultMaterials != null &amp;&amp; defaultMaterials.Length != 0)\n                {\n                    var val8 = Object.Instantiate(SRSingleton&lt;GameContext&gt;.Instance\n                        .SlimeDefinitions.GetSlimeByIdentifiableId(Identifiable.Id.PINK_SLIME).AppearancesDefault[0]\n                        .Structures[0]\n                        .DefaultMaterials[0]);\n                    val8.SetColor(\"_TopColor\", new Color32(0,0,0,0)); // (1)\n                    val8.SetColor(\"_MiddleColor\", new Color32(0,0,0,0));\n                    val8.SetColor(\"_BottomColor\", new Color32(0,0,0,0));\n                    val8.SetFloat(\"_Shininess\", 1f);\n                    val8.SetFloat(\"_Gloss\", 0f);\n                    structure.DefaultMaterials[0] = val8;\n                }\n            }\n\n            var expressionFaces = slimeAppearance.Face.ExpressionFaces;\n            foreach (var val9 in expressionFaces)\n            {\n                if (val9.Mouth)\n                {\n                    val9.Mouth.SetColor(\"_MouthBot\",\n                        new Color32(0x82, 0x82, 0xef, 0xff));\n                    val9.Mouth.SetColor(\"_MouthMid\",\n                        new Color32(0xa0, 0xa0, 0xff, 0xff));\n                    val9.Mouth.SetColor(\"_MouthTop\",\n                        new Color32(0xa0, 0xa0, 0xff, 0xff));\n                }\n\n                if (val9.Eyes)\n                {\n                    val9.Eyes.SetColor(\"_EyeRed\", new Color(26, 45, 56, byte.MaxValue)); // (2)\n                    val9.Eyes.SetColor(\"_EyeGreen\", new Color32(94, 141, 160, byte.MaxValue));\n                    val9.Eyes.SetColor(\"_EyeBlue\", new Color32(40, 60, 68, byte.MaxValue));\n                }\n            }\n\n            slimeAppearance.Face.OnEnable();\n            var val10 = slimeAppearance;\n            var colorPalette = default(SlimeAppearance.Palette);\n            colorPalette.Top = new Color32(252, 254, byte.MaxValue, byte.MaxValue); // (1)\n            colorPalette.Middle = new Color32(210, 236, 247, byte.MaxValue);\n            colorPalette.Bottom = new Color32(124, 138, 163, byte.MaxValue);\n            val10.ColorPalette = colorPalette;\n            go.GetComponent&lt;SlimeAppearanceApplicator&gt;().Appearance = slimeAppearance;\n\n            // Register the slimes to different registries\n            LookupRegistry.RegisterIdentifiablePrefab(go);\n            SlimeRegistry.RegisterSlimeDefinition(slimeDefinition);\n            AmmoRegistry.RegisterAmmoPrefab(PlayerState.AmmoMode.DEFAULT,\n                SRSingleton&lt;GameContext&gt;.Instance.LookupDirector.GetPrefab(ModdedIds.YOUR_SLIME));\n            var icon = slimeAppearance.Icon = Utils.LoadTexture(\"yourSlimeIcon\") // (3)\n            slimeAppearance.ColorPalette.Ammo = new Color32(210, 236, 247, 225);\n            SRSingleton&lt;GameContext&gt;.Instance.LookupDirector.GetPrefab(ModdedIds.YOUR_SLIME)\n                .GetComponent&lt;Vacuumable&gt;()\n                .size = Vacuumable.Size.LARGE;\n            TranslationPatcher.AddActorTranslation(\"l.your_slime\", \"Your Slime\"); // Make sure to use the Slimes ID with lower snake case (like_this)\n        }\n    }\n}\n</code></pre> Now load the function by calling <code>CreateSlime.CreateYourSlime()</code> in your Load() function</p>"},{"location":"SlimeRancher/tutorials/Creating%20Content/slimes/#creating-a-pedia-entry-optional","title":"Creating a Pedia Entry (optional)","text":"<p>You may want to add a Pedia Entry for your Slime First add this line into your EnumHolder EnumHolder<pre><code>public static readonly PediaDirector.Id YOUR_SLIME_ENTRY;\n</code></pre> Add this to the bottom of your CreateYourSlime() function: Register Pedia<pre><code>PediaRegistry.RegisterIdEntry(ModdedIds.YOUR_SLIME_ENTRY, icon);\n</code></pre> And last, add this to your PreLoad function, before patching all with the Harmony Instances: PreLoad<pre><code>RegisterIdentifiableMapping(PediaDirector.Id.PLORTS, ModdedIds.YOUR_SLIME/*(4)*/);\nRegisterIdentifiableMapping(ModdedIds.YOUR_SLIME_ENTRY, ModdedIds.YOUR_SLIME);\nSetPediaCategory(ModdedIds.YOUR_SLIME_ENTRY, PediaCategory.SLIMES);\nnew SlimePediaEntryTranslation(ModdedIds.YOUR_SLIME_ENTRY)\n    .SetTitleTranslation(\"Your Slimes\")\n    .SetIntroTranslation(\"INTRO\")\n    .SetDietTranslation(\"FOOD\")\n    .SetFavoriteTranslation(\"FAVOURITE_FOOD\")\n    .SetSlimeologyTranslation(\"SLIMEOLOGY_SECTION\")\n    .SetRisksTranslation(\"RISK_SECTION\")\n    .SetPlortonomicsTranslation(\"PLORT_SECTION\");\n</code></pre></p> <ol> <li>Make sure to change thy color</li> <li>Thou shall alter the colours. I don't really know how to really bring this to practical use</li> <li>See Image Loading</li> <li>This is the Item you need to collect, to get the Entry</li> </ol>"}]}